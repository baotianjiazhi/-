---
title: 面经
date: 2020-8-7 16:22:55
tags:
- 操作系统
- 计算机网络
top: 1
---

# 进程、线程、协程

进程是系统资源分配的基本单位，线程是系统调度的基本单位，协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。

![img](mianjing\进程、线程、协程.jpg)

进程、线程、协程的对比：

* 协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程、线程和进程不是一个维度的。
* 一个进程可以包含多个线程，一个线程可以包含多个协程。
* 一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。
* 协程与进程一样，切换是存在上下文切换问题的。



上下文切换：

* 进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。
* 线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。
* 协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。

## I/O的五种模型

1. 阻塞I/O模型
2. 非阻塞I/O模型
3. I/O复用模型
4. 信号驱动I/O模型
5. 异步I/O模型

<!--more-->

# 排序时间复杂度

![imp](mianjing\排序.jpg)



#  谈谈分布式缓存

第一次请求时将一些耗时操作的结果暂存，以后遇到相同的请求，直接返回暂存的数据。我想这是大部分童鞋对于缓存的理解。在计算机系统中，缓存无处不在，比如我们访问一个网页，网页和引用的 JS/CSS 等静态文件，根据不同的策略，会缓存在浏览器本地或是 CDN 服务器，那在第二次访问的时候，就会觉得网页加载的速度快了不少；比如微博的点赞的数量，不可能每个人每次访问，都从数据库中查找所有点赞的记录再统计，数据库的操作是很耗时的，很难支持那么大的流量，所以一般点赞这类数据是缓存在 Redis 服务集群中的。



GeeCache 基本上模仿了 [groupcache](https://github.com/golang/groupcache) 的实现，为了将代码量限制在 500 行左右（groupcache 约 3000 行），裁剪了部分功能。但总体实现上，还是与 groupcache 非常接近的。支持特性有：

* 单机缓存和基于 HTTP 的分布式缓存

* 最近最少访问(Least Recently Used, LRU) 缓存策略

* 使用 Go 锁机制防止缓存击穿
* 使用一致性哈希选择节点，实现负载均衡
* 使用 protobuf 优化节点间二进制通信



### 1.2 LFU(Least Frequently Used)

最少使用，也就是淘汰缓存中访问频率最低的记录。LFU 认为，如果数据过去被访问多次，那么将来被访问的频率也更高。LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序，淘汰时选择访问次数最少的即可。LFU 算法的命中率是比较高的，但缺点也非常明显，维护每个记录的访问次数，对内存的消耗是很高的；另外，如果数据的访问模式发生变化，LFU 需要较长的时间去适应，也就是说 LFU 算法受历史数据的影响比较大。例如某个数据历史上访问次数奇高，但在某个时间点之后几乎不再被访问，但因为历史访问次数过高，而迟迟不能被淘汰。

### 1.3 LRU(Least Recently Used)

最近最少使用，相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的一种淘汰算法。LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了，则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。

![img](mianjing\LRU逻辑图.jpg)

这张图很好地表示了 LRU 算法最核心的 2 个数据结构

* 绿色的是字典(map)，存储键和值的映射关系。这样根据某个键(key)查找对应的值(value)的复杂是O(1)，在字典中插入一条记录的复杂度也是O(1)。

* 红色的是双向链表(double linked list)实现的队列。将所有的值放到双向链表中，这样，当访问到某个值时，将其移动到队尾的复杂度是O(1)，在队尾新增一条记录以及删除一条记录的复杂度均为O(1)。

## 缓存

1. **缓存雪崩**：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。
2. **缓存击穿**：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。
3. **缓存穿透**：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。



## 分布式访问

​	对于分布式缓存来说，当一个节点接收到请求，如果该节点并没有存储缓存值，那么它面临的难题是，从谁那获取数据？自己，还是节点1, 2, 3, 4… 。假设包括自己在内一共有 10 个节点，当一个节点接收到请求时，随机选择一个节点，由该节点从数据源获取数据。

​	假设第一次随机选取了节点 1 ，节点 1 从数据源获取到数据的同时缓存该数据；那第二次，只有 1/10 的可能性再次选择节点 1, 有 9/10 的概率选择了其他节点，如果选择了其他节点，就意味着需要再一次从数据源获取数据，一般来说，这个操作是很耗时的。这样做，一是缓存效率低，二是各个节点上存储着相同的数据，浪费了大量的存储空间。

## 一致性哈希

### 2.1 步骤

一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。

![img](mianjing\一致性哈希.jpg)

- 计算节点/机器(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上。
- 计算 key 的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器。

### 2.2 数据倾斜问题

如果服务器的节点过少，容易引起 key 的倾斜。例如上面例子中的 peer2，peer4，peer6 分布在环的上半部分，下半部分是空的。那么映射到环下半部分的 key 都会被分配给 peer2，key 过度向 peer2 倾斜，缓存节点间负载不均。

为了解决这个问题，引入了虚拟节点的概念，一个真实节点对应多个虚拟节点。

假设 1 个真实节点对应 3 个虚拟节点，那么 peer1 对应的虚拟节点是 peer1-1、 peer1-2、 peer1-3（通常以添加编号的方式实现），其余节点也以相同的方式操作。

- 第一步，计算虚拟节点的 Hash 值，放置在环上。
- 第二步，计算 key 的 Hash 值，在环上顺时针寻找到应选取的虚拟节点，例如是 peer2-1，那么就对应真实节点 peer2。

虚拟节点扩充了节点的数量，解决了节点较少的情况下数据容易倾斜的问题。而且代价非常小，只需要增加一个字典(map)维护真实节点与虚拟节点的映射关系即可。

## Protobuf

> protobuf即 Protocol Buffers, Google 开发的一种数据描述语言，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf以二进制方式存储，占空间小



## 分布式节点





# 系统调用

[操作系统](https://baike.baidu.com/item/操作系统)的主要功能是为管理硬件资源和为[应用程序](https://baike.baidu.com/item/应用程序)开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，[内核](https://baike.baidu.com/item/内核)提供一系列具备预定功能的[多内核](https://baike.baidu.com/item/多内核)[函数](https://baike.baidu.com/item/函数)，通过一组称为系统调用（system call)的接口呈现给用户。系统调用把[应用程序](https://baike.baidu.com/item/应用程序)的请求传给[内核](https://baike.baidu.com/item/内核)，调用相应的内核[函数](https://baike.baidu.com/item/函数)完成所需的处理，将处理结果返回给应用程序。

### 系统中的程序类型及状态

操作系统中的状态分为**管态（核心态）和目态（用户态）**。**特权指令**：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。**访管指令**：本身是一条特殊的指令，但不是特权指令。（trap指令）。基本功能：“自愿进管”，能引起访管异常。

用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用[接口](https://baike.baidu.com/item/接口/15422203)使用系统调用。

### 系统功能调用

系统功能调用：就是用户在程序中使用“访管指令”调用由操作系统提供的子功能集合。其中每一个系统子功能称为一个系统调用命令，也叫广义指令。



中断向量：中断的地址的变量；

中断向量表：中断类型号与相应中断源的`中断处理程序入口地址`之间的连接表；

中断服务程序：发送中断时所执行的中断代码

# 进程通信方式

Linux下进程通信的八种方法：`管道(pipe)`，`命名管道(FIFO)`，`内存映射(mapped memeory)`，`消息队列(message queue)`，`共享内存(shared memory)`，`信号量(semaphore)`，`信号(signal)`，`套接字(Socket)`

1. 管道(pipe): 管道允许一个进程和另一个与它有共同祖先的进程之间进行通信；

   管道的特点：（1）半双工（2）只能用于有共同祖先的进程（3）特殊的文件，可以进行读写，但只存在于内存中

2. 命名管道（FIFO）：类似于管道，但是可以用于任意两个进程之间的通信

3. 内存映射（mapped memory）: 内存映射允许多个进程间进行通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它

4. 信号

5. 信号量(semaphore):主要用于进程间以及同进程的线程间进行同步

6. 共享内存（shared memory）：可以使得多个进程访问同一块内存空间，是最快的可用IPC形式。往往和其他通信机制共同使用，如结合信号量进行使用，以达到进程间的同步及互斥

7. 消息队列（message queue）：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；

   消息队列的特点：（1）消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级（2）消息队列独立于发送与接收进程。进程中止时，消息队列及其内容并不会被删除（3）消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取

8. 套接字（socket）：更为通用的进程间通信机制，可以用于不同机器之间的进程进行通信



# Redis

## 支持的数据类型

1. String
2. List
3. 集合
4. 有序集合
5. 哈希

##  String

```
> set name codehole
> get name
> exists name
> del name
> mget name1 name2 name3 // 批量读
> mset name1 bao name2 li name3 lv // 批量写
> expire name 5 // 5s后过期
> setex name 5 bao // 同时设置String的值和过期时间
> setnx name bao // 如果存在就不设置
> incr age // 自增1
> incrby age -5 // 减5
```



## List

​	Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是`链表`而不是`数组`。这意味着list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为O(n)。

​	当列表弹出最后一个元素之后，该数据结构会被自动删除并回收内存。

​	Redis的列表通常被当作异步队列来使用。将需要延后处理的任务结构体序列化为字符串塞进Redis的列表，另一个线程从这个列表中轮询数据进行处理。

**右边进左边出：队列**

```
> rpush books python java golang
> llen books
> lpop books
"python"
> lpop books
"java"
```

**右边进右边出：栈**

```
> rpush books python java golang
> rpop books
"golang"
```

**慢操作**

lindex 相当于 Java 链表的 get(int index)方法，它需要对链表进行遍历，性能随着参数index 增大而变差。 ltrim 和字面上的含义不太一样，个人觉得它叫 lretain(保留) 更合适一些，因为 ltrim 跟的两个参数 start_index 和 end_index 定义了一个区间，在这个区间内的值，ltrim 要保留，区间之外统统砍掉。我们可以通过 ltrim 来实现一个定长的链表，这一点非常有用。index 可以为负数，index=-1 表示倒数第一个元素，同样 index=-2 表示倒数第二个元素。

```
> lrange books 0 -1 // 遍历
> lindex books 1 // 时间复杂度为O(n)
```



# 利用Docker进行部署

1. 编写Dockerfile

```
FROM golang:alpine

# 为我们的镜像设置必要的环境变量
ENV GO111MODULE=on \
    CGO_ENABLED=0 \
    GOODS=linux\
    GOARCH=amd64

# 移动到工作目录: /build
WORKDIR /build

# 将代码复制到容器中
COPY . .

# 将我们的代码编译成二进制可执行文件app
RUN go build -o app .

# 声明服务端口
EXPOSE 8888

# 启动容器时运行的命令
CMD ["/build/app"]
```

2.  `docker build . -t web_app`
3. `docker run -p 8888:8888 goweb_app` 将docker系统的8888映射到操作系统的端口8888

4. 又因为我们的项目中使用了MySQL，我们可以选择使用如下命令启动一个MySQL容器，它的别名为`mysql8019`；root用户的密码为`root1234`；挂载容器中的`/var/lib/mysql`到本地的`/Users/q1mi/docker/mysql`目录；内部服务端口为3306，映射到外部的13306端口。

   `docker run --name mysql8019 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root1234 -v /Users/q1mi/docker/mysql:/var/lib/mysql -d mysql:8.0.19`

5. ```bash
   docker run --link=mysql8019:mysql8019 -p 8888:8888 bluebell_app
   
   
   
   
   
   ```

```


FROM golang:alpine AS builder

# 为我们的镜像设置必要的环境变量
ENV GO111MODULE=on \
    CGO_ENABLED=0 \
    GOOS=linux \
    GOARCH=amd64

# 移动到工作目录：/build
WORKDIR /build

# 复制项目中的 go.mod 和 go.sum文件并下载依赖信息
COPY go.mod .
COPY go.sum .
RUN go mod download

# 将代码复制到容器中
COPY . .

# 将我们的代码编译成二进制可执行文件 bubble
RUN go build -o bubble .

###################
# 接下来创建一个小镜像
###################
FROM scratch

COPY ./templates /templates
COPY ./static /static
COPY ./conf /conf

# 从builder镜像中把/dist/app 拷贝到当前目录
COPY --from=builder /build/bluebell /

# 需要运行的命令
ENTRYPOINT ["/bluebell", "conf/app.ini"]
```



# 加密

- 对称加密: 加密和解密的秘钥使用的是同一个.
- 非对称加密: 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。

**对称加密算法:** 密钥较短，破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，且对计算机性能要求也没有那么高.

**非对称加密算法:** 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

# Golang中的内存分配

![img](mianjing\内存分配.png)